# -*- coding: utf-8 -*-
"""Cópia de Banco_Fake_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x-0wZOGcL5Axlw2EN-0jqrv3DAPM5o86
"""

!git clone https://github.com/observatorio-do-amanha-ac/sandbox.git

"""### Instalação das bibliotecas externas

Quem optar por desenvolver localmente, ou seja, em um notebook rodando na sua própria máquina, não se esqueça de instalar as seguintes bibliotecas conforme descrito no README do repositório:

- pandas (pip install pandas)
- faker (pip install faker)
- duckdb (pip install duckdb)
- ipython_sql (pip install ipython_sql)

Para as pessoas que optarem pelo desenvolvimento integrado ao Google Colab, deve executar as células abaixo (o pandas já está instalado por padrão no ambiente do Google):

"""

!pip install faker

!pip install duckdb

"""## Importando as bibliotecas que iremos utilizar"""

import os
from datetime import date, datetime
import uuid
import sqlite3
import pandas as pd
import duckdb
from sqlalchemy import create_engine, text
import random
from faker import Faker

"""## Definindo o caminho do banco de dados

### Para desenvolvimento em um notebook local

Caso você opte por clonar o repositório para desenvolver localmente, utilize o código abaixo para garantir o caminho exato do arquivo `sqlite`:
"""

base_path = os.path.dirname(os.getcwd())
database_dir = os.path.join(base_path, "databases")

db_oltp_file = "banco_oltp_fake.db"
# db_olap_file =  "duckdb_olap_ac_fake_database.duckdb"

db_oltp_path = os.path.join(database_dir, db_oltp_file)
# db_olap_path = os.path.join(database_dir, db_olap_file)

"""### Para desenvolver no ambiente do Google Colab

Caso você queira utilizar o ambiente do Google Colaba para desenvolvimento, utilize o caminho do arquivo de dos bancos de dados seguindo clicando nos "3 pontinhos" ao lado direito dos arquivos na pasta `datasets` e escolhendo a opção "Copiar Caminho":
"""

# Define os caminhos do banco de dados no Colab
db_oltp_path = "/content/sandbox/databases/banco_oltp_fake.db"

"""## Restaura arquivo banco de dados

Essa função pode ser utilizada para restaurar o banco do zero caso você encontre algum problema... vai que, né?
"""

# Esta função restaura o arquivo de banco de dados
def db_restore(db_path):

    # Verifica se o arquivo existe
    if os.path.exists(db_path):
        # Remove o arquivo existente
        os.remove(db_path)
        print(f"Arquivo {db_path} removido.")
    else:
        print(f"Arquivo {db_path} não encontrado.")

    # Cria um novo arquivo SQLite
    with open(db_path, 'w') as file:
        pass  # Não adiciona nada ao arquivo

    print(f"Arquivo {db_path} criado ou substituído.")

db_restore(db_oltp_path)

"""## Abre a conexão com os bancos de dados"""

# Conexão ao banco de dados SQLite
sqlite_conn = sqlite3.connect(db_oltp_path)
cursor = sqlite_conn.cursor()

"""## Carregando o sql no colab para poder fazer consultas diretamente no prompt"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext sql
# %sql sqlite:///{db_oltp_path}

# # Conexão ao banco de dados DuckDB
# duckdb_conn = duckdb.connect(db_olap_path)

"""## Define o Schema do banco de dados transacional"""

# Script para criar as tabelas
schema_script = """
CREATE TABLE CAD_PESSOA (
    ID_PESSOA INTEGER PRIMARY KEY AUTOINCREMENT,
    NOME_COMPLETO VARCHAR(255),
    CPF VARCHAR(14),
    DATA_NASCIMENTO DATE,
    FAIXA_ETARIA VARCHAR(50),
    GENERO VARCHAR(50),
    ORIENTACAO_SEXUAL VARCHAR(50),
    RACA_ETNIA VARCHAR(50),
    FAIXA_DE_RENDA TEXT,
    ESCOLARIDADE VARCHAR(50),
    CEP VARCHAR(10),
    LOGRADOURO VARCHAR(255),
    NUMERO VARCHAR(10),
    BAIRRO VARCHAR(100),
    COMPLEMENTO VARCHAR(255),
    CIDADE VARCHAR(100),
    ESTADO VARCHAR(2),
    EMAIL VARCHAR(255),
    TELEFONE VARCHAR(20),
    AREA_DE_ATUACAO VARCHAR(100),
    ID_EMPRESA INTEGER,
    FOREIGN KEY (ID_EMPRESA) REFERENCES CAD_EMPRESA(ID_EMPRESA)
);

CREATE TABLE CAD_EMPRESA (
    ID_EMPRESA INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_PESSOA INTEGER,
    RAZAO_SOCIAL VARCHAR(255),
    NOME_FANTASIA VARCHAR(255),
    CNPJ VARCHAR(18),
    CEP VARCHAR(10),
    LOGRADOURO VARCHAR(255),
    NUMERO VARCHAR(10),
    COMPLEMENTO VARCHAR(255),
    BAIRRO VARCHAR(100),
    CIDADE VARCHAR(100),
    ESTADO VARCHAR(2),
    EMAIL VARCHAR(255),
    TELEFONE_CONTATO VARCHAR(20),
    FOREIGN KEY (ID_PESSOA) REFERENCES CAD_PESSOA(ID_PESSOA)
);

CREATE TABLE PROGRAMAS (
    ID_PROGRAMA INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_DOMINIO INTEGER,
    TITULO_PROGRAMA VARCHAR(255),
    FOREIGN KEY (ID_DOMINIO) REFERENCES DOMINIOS(ID_DOMINIO)
);

CREATE TABLE INSCRICOES (
    ID_INSCRICAO INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_PROGRAMA INTEGER,
    ID_PESSOA INTEGER,
    DATA_INSCRICAO DATE,
    FOREIGN KEY (ID_PROGRAMA) REFERENCES PROGRAMAS(ID_PROGRAMA),
    FOREIGN KEY (ID_PESSOA) REFERENCES CAD_PESSOA(ID_PESSOA)
);

CREATE TABLE PARTICIPANTE_PROGRAMA (
    ID_PROGRAMA INTEGER,
    ID_INSCRICAO INTEGER,
    PRIMARY KEY (ID_PROGRAMA, ID_INSCRICAO),
    FOREIGN KEY (ID_PROGRAMA) REFERENCES PROGRAMAS(ID_PROGRAMA),
    FOREIGN KEY (ID_INSCRICAO) REFERENCES INSCRICOES(ID_INSCRICAO)
);

CREATE TABLE DOMINIOS (
    ID_DOMINIO INTEGER PRIMARY KEY AUTOINCREMENT,
    NOME_DOMINIO VARCHAR(255),
    RESPONSAVEL_DOMINIO VARCHAR(255)
);

CREATE TABLE PROGRAMA_ODS (
    ID_PROGRAMA INTEGER,
    ID_ODS INTEGER,
    PRIMARY KEY (ID_PROGRAMA, ID_ODS),
    FOREIGN KEY (ID_PROGRAMA) REFERENCES PROGRAMAS(ID_PROGRAMA),
    FOREIGN KEY (ID_ODS) REFERENCES ONU_ODS(ID_ODS)
);

CREATE TABLE ONU_ODS (
    ID_ODS INTEGER PRIMARY KEY AUTOINCREMENT,
    NOME_ODS VARCHAR(255)
);

CREATE TABLE SERVICO (
    ID_SERVICO INTEGER PRIMARY KEY AUTOINCREMENT,
    TITULO_SERVICO VARCHAR(255)
);

CREATE TABLE AGENDAMENTO_SERVICO (
    ID_AGENDAMENTO INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_SERVICO INTEGER,
    ID_PESSOA INTEGER,
    DATA_AGENDAMENTO DATE,
    FOREIGN KEY (ID_SERVICO) REFERENCES SERVICO(ID_SERVICO),
    FOREIGN KEY (ID_PESSOA) REFERENCES CAD_PESSOA(ID_PESSOA)
);

CREATE TABLE LABORATORIOS (
    ID_LABORATORIO INTEGER PRIMARY KEY AUTOINCREMENT,
    NOME_LABORATORIO VARCHAR(255),
    DESCRICAO TEXT
);

CREATE TABLE EQUIPAMENTO (
    ID_EQUIPAMENTO INTEGER PRIMARY KEY AUTOINCREMENT,
    NOME_EQUIPAMENTO VARCHAR(255),
    DESCRICAO TEXT,
    DISPONIBILIDADE BOOLEAN,
    ID_LABORATORIO INTEGER,
    FOREIGN KEY (ID_LABORATORIO) REFERENCES LABORATORIOS(ID_LABORATORIO)
);

CREATE TABLE AGENDAMENTO_INFRA (
    ID_AGENDAMENTO_INFRA INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_AGENDAMENTO INTEGER,
    ID_LABORATORIO INTEGER,
    ID_EQUIPAMENTO INTEGER,
    FOREIGN KEY (ID_AGENDAMENTO) REFERENCES AGENDAMENTO_SERVICO(ID_AGENDAMENTO),
    FOREIGN KEY (ID_LABORATORIO) REFERENCES LABORATORIOS(ID_LABORATORIO),
    FOREIGN KEY (ID_EQUIPAMENTO) REFERENCES EQUIPAMENTO(ID_EQUIPAMENTO)
);

CREATE TABLE FORMULARIOS_FEEDBACK_PROGRAMAS (
    ID_FORMULARIO INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_INSCRICAO INTEGER,
    ID_PESSOA INTEGER,
    ID_DOMINIO INTEGER,
    P1 TEXT,
    P2 TEXT,
    P3 TEXT,
    P4 TEXT,
    P5 TEXT,
    P6 TEXT,
    P7 TEXT,
    P8 TEXT,
    P9 TEXT,
    NOME_FORMULARIO VARCHAR(255),
    DATA_CRIACAO DATE,
    FOREIGN KEY (ID_INSCRICAO) REFERENCES INSCRICOES(ID_INSCRICAO),
    FOREIGN KEY (ID_PESSOA) REFERENCES CAD_PESSOA(ID_PESSOA),
    FOREIGN KEY (ID_DOMINIO) REFERENCES DOMINIOS(ID_DOMINIO)
);

CREATE TABLE RESPOSTAS_FEEDBACK_PROGRAMAS (
    ID_RESPOSTA INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_PERGUNTA INTEGER,
    ID_PESSOA INTEGER,
    ID_FORMULARIO INTEGER,
    RESPOSTA TEXT,
    FOREIGN KEY (ID_PERGUNTA) REFERENCES PERGUNTAS_ADICIONAIS_FEEDBACK_PROGRAMAS(ID_PERGUNTA),
    FOREIGN KEY (ID_PESSOA) REFERENCES CAD_PESSOA(ID_PESSOA),
    FOREIGN KEY (ID_FORMULARIO) REFERENCES FORMULARIOS_FEEDBACK_PROGRAMAS(ID_FORMULARIO)
);

CREATE TABLE PERGUNTAS_ADICIONAIS_FEEDBACK_PROGRAMAS (
    ID_PERGUNTA INTEGER PRIMARY KEY AUTOINCREMENT,
    ID_DOMINIO INTEGER,
    PERGUNTA TEXT,
    FOREIGN KEY (ID_DOMINIO) REFERENCES DOMINIOS(ID_DOMINIO)
);

CREATE TABLE FEEDBACK_INFRAESTRUTURA (
    ID_PESSOA INTEGER,
    ID_AGENDAMENTO INTEGER,
    ID_PERGUNTA INTEGER,
    RESPOSTA TEXT,
    PRIMARY KEY (ID_PESSOA, ID_AGENDAMENTO, ID_PERGUNTA),
    FOREIGN KEY (ID_PESSOA) REFERENCES CAD_PESSOA(ID_PESSOA),
    FOREIGN KEY (ID_AGENDAMENTO) REFERENCES AGENDAMENTO_SERVICO(ID_AGENDAMENTO),
    FOREIGN KEY (ID_PERGUNTA) REFERENCES FEEDBACK_PERGUNTAS_INFRAESTRUTURA(ID_PERGUNTA)
);

CREATE TABLE FEEDBACK_PERGUNTAS_INFRAESTRUTURA (
    ID_PERGUNTA INTEGER PRIMARY KEY AUTOINCREMENT,
    PERGUNTA TEXT
);
"""

# Executar o script SQL para criar as tabelas
cursor.executescript(schema_script)

# Confirmar as alterações e fechar a conexão
sqlite_conn.commit()

print("Tabelas criadas com sucesso!")

# Consultar as tabelas existentes
cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")

# Recuperar e imprimir os nomes das tabelas
tables = cursor.fetchall()
print("Tabelas no banco de dados:\n")
x = 1
for table in tables:
    print(x,'-' , table[0])
    x += 1

"""## CAD_PESSOA"""

# Consultar as tabelas existentes
cursor.execute("PRAGMA table_info(CAD_PESSOA)")

# Recuperar e imprimir os nomes das tabelas
tables = cursor.fetchall()
print("Colunas no banco de dados:\n")
x = 1
for table in tables:
    print(x,'-' , table[1])
    x += 1

fake = Faker('pt_BR')

# Cria uma quantidade determinada de registros aleatórios no banco sqlite
def insert_into_cad_pessoa(qtd_registros=10):
    bairros = [
        "Agamenon Magalhães", "Alto do Moura", "Boa Vista", "Caiucá", "Cedro", "Centro", "Cidade Jardim",
        "Cohab I", "Cohab II", "Divinópolis", "Indianópolis", "Jardim Panorama", "João Mota", "Lagoa do Algodão",
        "Maurício de Nassau", "Monte Bom Jesus", "Nova Caruaru", "Petrópolis", "Pinheirópolis", "Salgado",
        "Rendeiras", "Santa Clara", "São Francisco", "São José", "São João da Escócia", "Universitário",
        "Vassoural", "Vila Kennedy", "Xique xique"
    ]

    emails_gerados = set()  # Conjunto para garantir unicidade dos e-mails
    cpfs_gerados = set()  # Conjunto para garantir unicidade dos CPFs

    for _ in range(qtd_registros):
        # id_pessoa = str(uuid.uuid4())
        nome_completo = fake.name()

        # Garantir que o CPF seja único
        cpf = fake.cpf()
        while cpf in cpfs_gerados:
            cpf = fake.cpf()
        cpfs_gerados.add(cpf)

        data_nascimento = fake.date_of_birth(minimum_age=18, maximum_age=90).strftime('%Y-%m-%d')

        # Calcular faixa etária com base na data de nascimento
        idade = (fake.date_this_year().year - int(data_nascimento[:4]))
        if idade < 18:
            faixa_etaria = 'Menor de idade'
        elif 18 <= idade <= 29:
            faixa_etaria = '18 a 29 anos'
        elif 30 <= idade <= 59:
            faixa_etaria = '30 a 59 anos'
        else:
            faixa_etaria = '60 anos ou mais'

        genero = random.choice(['Masculino', 'Feminino', 'Outro'])
        orientacao_sexual = random.choice(['Heterossexual', 'Homossexual', 'Bissexual', 'Outro'])
        raca_etnia = random.choice(['Branca', 'Preta', 'Parda', 'Amarela', 'Indígena'])
        faixa_de_renda = random.choice(['Até 1 salário mínimo', '1 a 3 salários mínimos', '3 a 5 salários mínimos', 'Mais de 5 salários mínimos'])
        escolaridade = random.choice(['Ensino Fundamental', 'Ensino Médio', 'Ensino Superior', 'Pós-graduação'])
        cep = fake.postcode()
        logradouro = fake.street_name()
        numero = str(fake.building_number())
        bairro = random.choice(bairros)
        complemento = fake.neighborhood()
        cidade = random.choice(['Caruaru','Belo Jardim','Recife','São Caetano','Bezerros','Toritama'])
        estado = 'PE'
        area_de_atuacao = random.choice(['Tecnologia', 'Educação', 'Saúde', 'Comércio', 'Indústria', 'Serviços'])
        telefone = fake.phone_number()

        # Garantir que o e-mail seja único
        email = fake.email()
        while email in emails_gerados:
            email = fake.email()
        emails_gerados.add(email)

        # Inserir os dados na tabela CAD_PESSOA
        cursor.execute('''
            INSERT INTO CAD_PESSOA (
                NOME_COMPLETO, CPF, DATA_NASCIMENTO, FAIXA_ETARIA, GENERO, ORIENTACAO_SEXUAL, RACA_ETNIA, FAIXA_DE_RENDA, ESCOLARIDADE, CEP,
                LOGRADOURO, NUMERO, BAIRRO, COMPLEMENTO, CIDADE, ESTADO, EMAIL, TELEFONE, AREA_DE_ATUACAO
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (nome_completo, cpf, data_nascimento, faixa_etaria, genero, orientacao_sexual, raca_etnia, faixa_de_renda, escolaridade, cep,
              logradouro, numero, bairro, complemento, cidade, estado, email, telefone, area_de_atuacao))

    # Confirmar as alterações
    sqlite_conn.commit()

# Inserir 1000 registros fictícios na tabela CAD_PESSOA
insert_into_cad_pessoa(1000)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM CAD_PESSOA
# WHERE AREA_DE_ATUACAO = 'Tecnologia'
# LIMIT 2

cursor.execute("SELECT * FROM CAD_PESSOA")
print(cursor.fetchall())

"""## CAD_EMPRESA"""

cursor.execute("PRAGMA table_info(CAD_EMPRESA)")

tables = cursor.fetchall()
print("Tabelas no banco de dados:\n")
x = 1
for table in tables:
    print(x,'-' , table[1])
    x += 1

def insert_into_cad_empresa(qtd_empresas=10):
    bairros = [
          "Agamenon Magalhães", "Alto do Moura", "Boa Vista", "Caiucá", "Cedro", "Centro", "Cidade Jardim",
          "Cohab I", "Cohab II", "Divinópolis", "Indianópolis", "Jardim Panorama", "João Mota", "Lagoa do Algodão",
          "Maurício de Nassau", "Monte Bom Jesus", "Nova Caruaru", "Petrópolis", "Pinheirópolis", "Salgado",
          "Rendeiras", "Santa Clara", "São Francisco", "São José", "São João da Escócia", "Universitário",
          "Vassoural", "Vila Kennedy", "Xique xique"
      ]

    for _ in range(qtd_empresas):
        # id_empresa = str(uuid.uuid4())
        razao_social = fake.company()
        nome_fantasia = fake.company_suffix() + " " + fake.company()
        cnpj = fake.cnpj()
        cep = fake.postcode()
        logradouro = fake.street_name()
        numero = str(fake.building_number())
        complemento = fake.neighborhood()
        bairro = random.choice(bairros)
        cidade = 'Caruaru'
        estado = 'PE'
        email = fake.company_email()
        telefone_contato = fake.phone_number()

        # Inserir os dados na tabela CAD_EMPRESA
        cursor.execute('''
            INSERT INTO CAD_EMPRESA (
                RAZAO_SOCIAL, NOME_FANTASIA, CNPJ, CEP, LOGRADOURO, NUMERO, COMPLEMENTO, BAIRRO, CIDADE, ESTADO, EMAIL, TELEFONE_CONTATO
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (razao_social, nome_fantasia, cnpj, cep, logradouro, numero, complemento, bairro, cidade, estado, email, telefone_contato))

    # Confirmar as alterações
    sqlite_conn.commit()

# Inserir 100 empresas fictícias na tabela CAD_EMPRESA
insert_into_cad_empresa(100)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM CAD_EMPRESA
# LIMIT 2

"""Pegando Ids das empresas para vincular com pessoas"""

cursor.execute("SELECT * FROM CAD_EMPRESA")

ids_empresa = []
rows = cursor.fetchall()
print("IDS da empresas:\n")
for row in rows:
    ids_empresa.append(row[0])

print(ids_empresa)

"""Pegando 100 ids de pessoas aleatórios para vincular com empresa"""

cursor.execute("SELECT * FROM CAD_PESSOA")

ids_pessoa = []
rows = cursor.fetchall()
for row in rows:
  ids_pessoa.append(row[0])

print("Todos os ids")
print(ids_pessoa, '\n')

id_pessoa = random.sample(ids_pessoa, min(100, len(ids_pessoa)))
print("IDS de algumas pessoas:\n")
print(ids_pessoa)

"""Vinculando empresas a pessoas"""

num_vinculos = min(len(ids_empresa), len(ids_pessoa))

for i in range(num_vinculos):
    id_pessoa = ids_pessoa[i]
    id_empresa = ids_empresa[i]

    cursor.execute("UPDATE CAD_PESSOA SET ID_EMPRESA = ? WHERE ID_PESSOA = ?", (id_empresa, id_pessoa))
    cursor.execute("UPDATE CAD_EMPRESA SET ID_PESSOA = ? WHERE ID_EMPRESA = ?", (id_pessoa, id_empresa))


sqlite_conn.commit()

print(f"{num_vinculos} pessoas foram vinculadas a empresas de forma aleatória.")

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM CAD_PESSOA
# WHERE ID_EMPRESA IS NOT NULL
# LIMIT 3

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM CAD_EMPRESA
# WHERE ID_PESSOA IS NOT NULL
# LIMIT 3

"""Verificando o nome da empresa de determinadas pessoas:"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT CP.NOME_COMPLETO, CE.RAZAO_SOCIAL, CE.CNPJ,CP.AREA_DE_ATUACAO
# FROM CAD_EMPRESA AS CE
# JOIN CAD_PESSOA AS CP
# ON CE.ID_EMPRESA = CP.ID_EMPRESA
# LIMIT 10

"""## DOMÍNIOS"""

# Dicionário que mapeia cada domínio ao seu respectivo responsável
mapa_dominio_responsavel = {
    "Gestão": "Pâmela",
    "Inovação Aberta": "Lais",
    "Equidade de gênero": "Gabi",
    "Empreendedorismo": "Mirelli",
    "Suporte em TI": "Lucas",
    "Comunicação e Marketing": "Bono"
}

def inserir_into_dominios(map):

    nomes_dominios = list(map.keys())
    responsaveis_dominio = list(map.values())
    qtd_dominios = len(nomes_dominios)

    for i in range(qtd_dominios):

        # Selecionar o responsável correspondente ao domínio
        id_dominio = int(i) + 1
        responsavel_dominio = responsaveis_dominio[i]
        nome_dominio = nomes_dominios[i]

        cursor.execute('''
            INSERT INTO DOMINIOS (ID_DOMINIO, NOME_DOMINIO, RESPONSAVEL_DOMINIO)
            VALUES (?, ?, ?)
        ''', (id_dominio, nome_dominio, responsavel_dominio))

    sqlite_conn.commit()


inserir_into_dominios(mapa_dominio_responsavel)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM DOMINIOS

"""## PROGRAMAS"""

programas_dominios = {
    "Clubes de Programação": 3,
    "Elas que Lideram": 3,
    "Mulheres no Alto": 3,
    "Minas Data Lab": 3,
    "Transforma": 3,
    "Minas na Produção": 3,
    "Agreste Futurista": 3,
    "Observatório do amanhã":2,
    "Desafios de sustentabilidade": 2,
    "MMA (moda x música x audiovisual)": 2,
    ".GOV + Dotlab": 2,
    "Ciclo de inovação aberta": 2,
    "Incubação":4,
    "Mind the Bizz": 4,
    "Agreste Moda": 4,
}

def insert_into_programa():

    titulos_programas = list(programas_dominios.keys())
    dominios_programas = list(programas_dominios.values())
    qtd_programas = len(titulos_programas)

    for i in range(qtd_programas):

        # id_programa = str(uuid.uuid4())
        titulo_programa = titulos_programas[i]
        id_dominio_programa = dominios_programas[i]
        cursor.execute('''
            INSERT INTO PROGRAMAS (ID_DOMINIO, TITULO_PROGRAMA)
            VALUES (?, ?)
        ''', (id_dominio_programa, titulo_programa))

    sqlite_conn.commit()

insert_into_programa()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM PROGRAMAS

"""## INSCRICOES"""

def insert_into_inscricoes_programas(qtd_registros=10):
    cursor.execute("SELECT ID_PESSOA FROM CAD_PESSOA")
    pessoas = cursor.fetchall()
    cursor.execute("SELECT ID_PROGRAMA FROM PROGRAMAS")
    programas = cursor.fetchall()

    # Define o intervalo de datas
    data_inicio = date(2024, 1, 15)
    data_fim = date(2024, 8, 1)

    for _ in range(qtd_registros):
        # id_inscricao = str(uuid.uuid4())
        id_programa = random.choice(programas)[0]
        id_pessoa = random.choice(pessoas)[0]
        data_inscricao = fake.date_between(start_date=data_inicio, end_date=data_fim).strftime('%Y-%m-%d')

        cursor.execute('''
            INSERT INTO INSCRICOES (ID_PROGRAMA, ID_PESSOA, DATA_INSCRICAO)
            VALUES (?, ?, ?)
        ''', (id_programa, id_pessoa, data_inscricao))

    sqlite_conn.commit()

insert_into_inscricoes_programas(350)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM INSCRICOES
# LIMIT 2

"""## Participante Programa"""

def insert_into_programas_participante(qtd_registros=10):
    cursor.execute("SELECT ID_PROGRAMA FROM PROGRAMAS")
    programas = cursor.fetchall()
    cursor.execute("SELECT ID_INSCRICAO FROM INSCRICOES")
    inscricoes = cursor.fetchall()

    for _ in range(qtd_registros):
        id_inscricao = random.choice(inscricoes)[0]
        id_programa = random.choice(programas)[0]

        # Verifica se a combinação já existe
        cursor.execute('''
            SELECT COUNT(*) FROM PARTICIPANTE_PROGRAMA
            WHERE ID_PROGRAMA = ? AND ID_INSCRICAO = ?
        ''', (id_programa, id_inscricao))

        if cursor.fetchone()[0] == 0:
            cursor.execute('''
                INSERT INTO PARTICIPANTE_PROGRAMA (ID_PROGRAMA, ID_INSCRICAO)
                VALUES (?, ?)
            ''', (id_programa, id_inscricao))

    sqlite_conn.commit()

insert_into_programas_participante(250)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM PARTICIPANTE_PROGRAMA
# LIMIT 2

"""## ONU ODS"""

ods = [
    "Erradicação da pobreza",
    "Fome zero e agricultura sustentável",
    "Saúde e bem-estar",
    "Educação de qualidade",
    "Igualdade de gênero",
    "Água potável e saneamento",
    "Energia limpa e sustentável",
    "Trabalho decente e inclusão social",
    "Indústria, inovação e infraestrutura",
    "Redução das desigualdades",
    "Cidades e comunidades sustentáveis",
    "Consumo e produção sustentáveis",
    "Ação contra mudança global do clima",
    "Vida na água",
    "Vida terrestre",
    "Paz, justiça e participação humanitária",
    "Parcerias e meios de implementação",
]

def insert_into_onu_ods(ods_list):

    for i in range(len(ods_list)):
        id_ods = int(i) + 1
        nome_ods = ods_list[i]
        cursor.execute('''
            INSERT INTO ONU_ODS (ID_ODS ,NOME_ODS)
            VALUES (?,?)
        ''', (id_ods, nome_ods))

    print('Dados inseridos')
    sqlite_conn.commit()

insert_into_onu_ods(ods)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM ONU_ODS

"""## PROGRAMA ODS"""

"""
ID_ODS	NOME_ODS
1	Erradicação da pobreza
2	Fome zero e agricultura sustentável
3	Saúde e bem-estar
4	Educação de qualidade
5	Igualdade de gênero
6	Água potável e saneamento
7	Energia limpa e sustentável
8	Trabalho decente e inclusão social
9	Indústria, inovação e infraestrutura
10	Redução das desigualdades
11	Cidades e comunidades sustentáveis
12	Consumo e produção sustentáveis
13	Ação contra mudança global do clima
14	Vida na água
15	Vida terrestre
16	Paz, justiça e participação humanitária
17	Parcerias e meios de implementação


ID_PROGRAMA	ID_DOMINIO	TITULO_PROGRAMA
f5708e06-7275-4ac4-9238-7badeff9526a	3	Clubes de Programação x
9e6d4edb-4b7e-4c44-861a-5371c92be3ba	3	Elas que Lideram x
c1a880d5-b588-4f60-973f-205038cbf557	3	Mulheres no Alto x
4a2cc63b-c001-4448-a7ff-92c8862a8e09	3	Minas Data Lab x
42fb79f6-c130-412d-9b1f-208bb869dcd4	3	Transforma x
08f528ba-b9ac-4363-8855-36c64e31f5e3	3	Minas na Produção x
841e72ad-d6f1-4e1a-bca8-e188846eb343	3	Agreste Futurista x
f20f572f-ed8d-4dc3-9d28-7575dc8a66c2	2	Observatório do amanhã x
66235451-3a0e-4c2a-8de5-05721aa90203	2	Desafios de sustentabilidade x
8efd2598-eed4-4dfc-86e8-bcb4e560644e	2	MMA (moda x música x audiovisual) x
2dddf8ea-8352-4d06-855a-2eabacd501ba	2	.GOV + Dotlab x
2d8f2fe1-4f47-46e0-8dde-dd32bf0bf184	2	Ciclo de inovação aberta x
b94dbffe-40f4-483c-80d0-6d096baf936d	4	Incubação x
dc3c19d4-74d6-42bd-a6b9-33fcba5385b0	4	Mind the Bizz  x
1ebfffbd-908c-4ee2-a07b-9154d715f966	4	Agreste Moda
"""
# programa_ods = [
#     ('f5708e06-7275-4ac4-9238-7badeff9526a', 4),
#     ('f5708e06-7275-4ac4-9238-7badeff9526a', 5),
#     ('f5708e06-7275-4ac4-9238-7badeff9526a', 10),
#     ('9e6d4edb-4b7e-4c44-861a-5371c92be3ba', 10),
#     ('c1a880d5-b588-4f60-973f-205038cbf557', 5),
#     ('c1a880d5-b588-4f60-973f-205038cbf557', 10),
#     ('4a2cc63b-c001-4448-a7ff-92c8862a8e09', 10),
#     ('4a2cc63b-c001-4448-a7ff-92c8862a8e09', 5),
#     ('42fb79f6-c130-412d-9b1f-208bb869dcd4', 10),
#     ('08f528ba-b9ac-4363-8855-36c64e31f5e3', 10),
#     ('08f528ba-b9ac-4363-8855-36c64e31f5e3', 5),
#     ('841e72ad-d6f1-4e1a-bca8-e188846eb343', 5),
#     ('841e72ad-d6f1-4e1a-bca8-e188846eb343', 10),
#     ('f20f572f-ed8d-4dc3-9d28-7575dc8a66c2', 9),
#     ('f20f572f-ed8d-4dc3-9d28-7575dc8a66c2', 11),
#     ('66235451-3a0e-4c2a-8de5-05721aa90203', 9),
#     ('66235451-3a0e-4c2a-8de5-05721aa90203', 11),
#     ('8efd2598-eed4-4dfc-86e8-bcb4e560644e', 12),
#     ('2dddf8ea-8352-4d06-855a-2eabacd501ba', 17),
#     ('2d8f2fe1-4f47-46e0-8dde-dd32bf0bf184', 9),
#     ('b94dbffe-40f4-483c-80d0-6d096baf936d', 4),
#     ('b94dbffe-40f4-483c-80d0-6d096baf936d', 9),
#     ('dc3c19d4-74d6-42bd-a6b9-33fcba5385b0', 4),
#     ('dc3c19d4-74d6-42bd-a6b9-33fcba5385b0', 9),
#     ('1ebfffbd-908c-4ee2-a07b-9154d715f966', 8),
# ]

cursor.execute('SELECT ID_PROGRAMA, TITULO_PROGRAMA FROM PROGRAMAS')
programa_ods = cursor.fetchall()

programas = [item[0] for item in programa_ods]
programas_titulo = [item[1] for item in programa_ods]

print(programas)
print(programas_titulo)
ods = [4,5,10,10,5,10,10,5,10,10,5,5,10,9,11,9,11,12,17,9,4,9,4,9,8]


def insert_into_programa_ods():

  ids_programas = [item[0] for item in programa_ods]

  for i in range(len(ids_programas)):
    id_programa = ids_programas[i]
    id_ods = ods[i]

    cursor.execute('''
        INSERT INTO PROGRAMA_ODS (ID_PROGRAMA ,ID_ODS)
        VALUES (?,?)
    ''', (id_programa, id_ods))

    sqlite_conn.commit()

sqlite_conn.commit()
insert_into_programa_ods()

# Commented out IPython magic to ensure Python compatibility.
# %reload_ext sql

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT ID_PROGRAMA, TITULO_PROGRAMA
# FROM PROGRAMAS

cursor.execute('SELECT * FROM PROGRAMA_ODS')
print(cursor.fetchall())

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT PR.TITULO_PROGRAMA, O.NOME_ODS
# FROM PROGRAMA_ODS AS PO
# JOIN ONU_ODS AS O
# ON O.ID_ODS = PO.ID_ODS
# JOIN PROGRAMAS AS PR
# ON PR.ID_PROGRAMA = PO.ID_PROGRAMA
# 
# ORDER BY NOME_ODS

"""## SERVIÇO"""

servicos = [
    "Coworking",
    "Laboratórios de Criação e Prototipagem",
    "Capacitação e Formação",
    "Apoio a Startups",
    "Eventos e Networking",
]

def insert_into_servicos(lista_servicos):

    for servico in lista_servicos:
        cursor.execute('''
            INSERT INTO SERVICO (TITULO_SERVICO)
            VALUES (?)
        ''', (servico,))

    sqlite_conn.commit()

insert_into_servicos(servicos)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM SERVICO

"""## AGENDAMENTO SERVICO"""

def insert_into_agendamento_servico(qtd_registros=10):
    cursor.execute("SELECT ID_SERVICO FROM SERVICO")
    servicos = cursor.fetchall()
    cursor.execute("SELECT ID_PESSOA FROM CAD_PESSOA")
    pessoas = cursor.fetchall()

    data_inicio = date(2024, 1, 15)
    data_fim = date(2024, 8, 1)

    for _ in range(qtd_registros):
        # id_agendamento = str(uuid.uuid4())
        id_servico = random.choice(servicos)[0]
        id_pessoa = random.choice(pessoas)[0]
        datetime_agendamento = fake.date_between(start_date=data_inicio, end_date=data_fim).strftime('%Y-%m-%d %H:%M:%S')

        cursor.execute('''
            INSERT INTO AGENDAMENTO_SERVICO (ID_SERVICO, ID_PESSOA, DATA_AGENDAMENTO)
            VALUES (?, ?, ?)
        ''', (id_servico, id_pessoa, datetime_agendamento))

    sqlite_conn.commit()

insert_into_agendamento_servico(500)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# PRAGMA table_info(AGENDAMENTO_SERVICO)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM AGENDAMENTO_SERVICO
# LIMIT 2

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT AGS.ID_AGENDAMENTO, SE.TITULO_SERVICO, SE.ID_SERVICO
# FROM AGENDAMENTO_SERVICO AS AGS
# JOIN SERVICO AS SE
# ON SE.ID_SERVICO = AGS.ID_SERVICO
# WHERE SE.TITULO_SERVICO = 'Laboratórios de Criação e Prototipagem'
# LIMIT 2

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT count(ID_AGENDAMENTO) as Quantidade,  SE.TITULO_SERVICO as Titulo
# FROM AGENDAMENTO_SERVICO AS AGS
# JOIN SERVICO AS SE
# ON AGS.ID_SERVICO = SE.ID_SERVICO
# 
# GROUP BY SE.TITULO_SERVICO

"""## Laboratórios"""

mapa_laboratorios_descricao = {
    "Edição de Imagem": "Laboratório especializado em edição de fotos e imagens digitais, com softwares de ponta para manipulação visual.",
    "Podcast/Musical": "Espaço dedicado à gravação de podcasts e produções musicais, com equipamentos modernos e isolamento acústico.",
    "Criação e Prototipagem": "Laboratório voltado para a criação e prototipagem de produtos físicos e digitais, utilizando ferramentas de design e fabricação.",
    "Fotografia": "Laboratório equipado para sessões fotográficas profissionais, com iluminação controlada e câmeras de alta resolução.",
    "Salas de Treinamento e Reunião": "Espaço amplo e equipado para reuniões e treinamentos, com tecnologia de suporte para apresentações.",
    "Salas Empresariais": "Salas empresariais para startups e empresas estabelecidas, oferecendo um ambiente de trabalho profissional.",
    "Incubadora": "Espaço de incubação para startups, com apoio técnico e mentorias para o crescimento de novos negócios.",
    "Showroom": "Espaço dedicado à exposição de produtos e soluções, ideal para eventos e demonstrações comerciais."
}

nome_laboratorios = list(mapa_laboratorios_descricao.keys())
descricao_laboratorios = list(mapa_laboratorios_descricao.values())

def inserir_laboratorios():
  for i in range(len(nome_laboratorios)):
    # id_laboratorio = str(uuid.uuid4())
    nome_laboratorio = nome_laboratorios[i]
    descricao_laboratorio = descricao_laboratorios[i]

    cursor.execute('''
     INSERT INTO LABORATORIOS (NOME_LABORATORIO, DESCRICAO)
            VALUES (?, ?)
        ''''', (nome_laboratorio,descricao_laboratorio))

    print(nome_laboratorio, 'Inserido com sucesso')

    sqlite_conn.commit()

inserir_laboratorios()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM LABORATORIOS

"""## Equipamentos"""

mapa_equipamentos_descricao = {
    "VisionStation XG": "Estação de trabalho de alta performance para edição de imagem.",
    "PixelCraft Pro": "Computador dedicado à manipulação e edição de imagens digitais.",
    "ColorSync Ultra": "Monitor com alta precisão de cores para designers e editores de imagem.",
    "RenderMax Pro": "Servidor potente para renderização de imagens e vídeos.",
    "Wacom Intuitiv XL": "Mesa digitalizadora de alta precisão para ilustração e edição.",
    "SoundForge Studio": "Mesa de som profissional para gravação de podcasts e música.",
    "VocalSync X1": "Microfone condensador de alta qualidade para gravação de vozes.",
    "BassLine 2000": "Interface de áudio para produção e mixagem musical.",
    "PodCaster Pro": "Mixer dedicado para gravação e transmissão de podcasts.",
    "EchoTuner 8X": "Sintetizador avançado para produção musical.",
    "LightMaster 5K": "Iluminação profissional para estúdios de fotografia.",
    "LensPro 300": "Câmera DSLR profissional de alta resolução.",
    "SnapCapture X": "Sistema automatizado para captura de imagens de alta qualidade.",
    "FocusBeam 200": "Lentes de precisão para fotografia macro.",
    "PhotoSync Lab": "Computador dedicado para processamento de imagens RAW.",
    "MakerBot 3D Plus": "Impressora 3D de alta precisão para prototipagem.",
    "SewMaster Pro": "Máquina de costura industrial para moda e prototipagem.",
    "ProtoFab X1": "Cortadora a laser para criação de protótipos detalhados.",
    "FabricForge 4D": "Máquina de bordado digital de alta precisão.",
    "ModelIt 3D": "Scanner 3D para criação de modelos digitais."
}

nome_equipamentos = list(mapa_equipamentos_descricao.keys())
descricao_equipamentos = list(mapa_equipamentos_descricao.values())

cursor.execute('SELECT * FROM LABORATORIOS')
ids_laboratorios = cursor.fetchall()

def inserir_equipamento():
  for i in range(len(nome_equipamentos)):
    # id_equipamento = str(uuid.uuid4())
    nome_equipamento = nome_equipamentos[i]
    descricao_equipamento = descricao_equipamentos[i]
    disponibilidade = random.choices([True, False], weights=[0.7, 0.3])[0]

    if i <= 4:
        id_laboratorio = ids_laboratorios[0][0]
    elif i <= 9:
        id_laboratorio = ids_laboratorios[1][0]
    elif i <= 14:
        id_laboratorio = ids_laboratorios[2][0]
    elif i <= 19:
        id_laboratorio = ids_laboratorios[3][0]

    cursor.execute('''
      INSERT INTO EQUIPAMENTO (NOME_EQUIPAMENTO, DESCRICAO, DISPONIBILIDADE, ID_LABORATORIO)
              VALUES (?, ?, ?, ?)
          ''''', (nome_equipamento,descricao_equipamento,disponibilidade,id_laboratorio))

    print(nome_equipamento, 'Inserido com sucesso')

    sqlite_conn.commit()

inserir_equipamento()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM EQUIPAMENTO

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT NOME_EQUIPAMENTO, NOME_LABORATORIO
# FROM EQUIPAMENTO AS EQ
# JOIN LABORATORIOS AS LAB
# ON EQ.ID_LABORATORIO = LAB.ID_LABORATORIO
# Limit 10

"""## Agendamento INFRA"""

cursor.execute('''
SELECT AGS.ID_AGENDAMENTO, SE.TITULO_SERVICO, SE.ID_SERVICO
FROM AGENDAMENTO_SERVICO AS AGS
JOIN SERVICO AS SE
ON SE.ID_SERVICO = AGS.ID_SERVICO
WHERE SE.TITULO_SERVICO = 'Laboratórios de Criação e Prototipagem'
''')
ids_agendamento = cursor.fetchall()

cursor.execute('SELECT * FROM LABORATORIOS')
ids_laboratorios = cursor.fetchall()
cursor.execute('SELECT * FROM EQUIPAMENTO')
id_equipamentos = cursor.fetchall()

def inserir_agendamento_infra():

  lista_id_laboratorios = []
  for i in range(len(ids_laboratorios)):
    lista_id_laboratorios.append(ids_laboratorios[i][0])

  lista_id_equipamentos = []
  for i in range(len(id_equipamentos)):
    lista_id_equipamentos.append(id_equipamentos[i][0])


  for i in range(len(ids_agendamento)):
    # id_agendamento_infra = str(uuid.uuid4())
    id_agendamento = ids_agendamento[i][0]
    id_laboratorio = random.choice(lista_id_laboratorios)
    id_equipamento = random.choice(lista_id_equipamentos)
    cursor.execute('''
      INSERT INTO AGENDAMENTO_INFRA (ID_AGENDAMENTO, ID_LABORATORIO, ID_EQUIPAMENTO)
              VALUES (?, ?, ?)
          ''''', (id_agendamento,id_laboratorio,id_equipamento))
    sqlite_conn.commit()

inserir_agendamento_infra()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM AGENDAMENTO_INFRA
# LIMIT 5

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT NOME_LABORATORIO, NOME_EQUIPAMENTO, COUNT(ID_AGENDAMENTO_INFRA) AS AGENDAMENTOS
# FROM AGENDAMENTO_INFRA AS AGI
# JOIN EQUIPAMENTO AS EQ
# ON AGI.ID_EQUIPAMENTO = EQ.ID_EQUIPAMENTO
# JOIN LABORATORIOS AS LAB
# ON AGI.ID_LABORATORIO = LAB.ID_LABORATORIO
# 
# GROUP BY NOME_EQUIPAMENTO
# ORDER BY AGENDAMENTOS DESC

"""## FORMULARIOS_FEEDBACK_PROGRAMAS"""

cursor.execute('SELECT ID_INSCRICAO FROM INSCRICOES')
ids_inscricao = [row[0] for row in cursor.fetchall()]

# Obter IDs de CAD_PESSOA
cursor.execute('SELECT ID_PESSOA FROM CAD_PESSOA')
ids_pessoa = [row[0] for row in cursor.fetchall()]

# Obter IDs de DOMINIOS
cursor.execute('SELECT ID_DOMINIO FROM DOMINIOS')
ids_dominio = [row[0] for row in cursor.fetchall()]

# Gerar dados para FORMULARIOS_FEEDBACK_PROGRAMAS
def gerar_dados_feedback():
    for _ in range(100):  # Ajuste o número de registros conforme necessário
        # id_formulario = str(uuid.uuid4())
        id_inscricao = random.choice(ids_inscricao)
        id_pessoa = random.choice(ids_pessoa)
        id_dominio = random.choice(ids_dominio)
        p1 = f"Resposta P1 {random.randint(1, 100)}"
        p2 = f"Resposta P2 {random.randint(1, 100)}"
        p3 = f"Resposta P3 {random.randint(1, 100)}"
        p4 = f"Resposta P4 {random.randint(1, 100)}"
        p5 = f"Resposta P5 {random.randint(1, 100)}"
        p6 = f"Resposta P6 {random.randint(1, 100)}"
        p7 = f"Resposta P7 {random.randint(1, 100)}"
        p8 = f"Resposta P8 {random.randint(1, 100)}"
        p9 = f"Resposta P9 {random.randint(1, 100)}"
        nome_formulario = f"Formulário {random.randint(1, 100)}"
        data_criacao = f"2024-{random.randint(1, 12):02d}-{random.randint(1, 28):02d}"

        cursor.execute('''
            INSERT INTO FORMULARIOS_FEEDBACK_PROGRAMAS (
                ID_INSCRICAO, ID_PESSOA, ID_DOMINIO,
                P1, P2, P3, P4, P5, P6, P7, P8, P9,
                NOME_FORMULARIO, DATA_CRIACAO
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            id_inscricao, id_pessoa, id_dominio,
            p1, p2, p3, p4, p5, p6, p7, p8, p9,
            nome_formulario, data_criacao
        ))

    sqlite_conn.commit()

# Chamar a função para inserir dados
gerar_dados_feedback()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT COUNT(NOME_COMPLETO) AS QUANTIDADE_DE_FEEDBACKS, TITULO_PROGRAMA
# FROM FORMULARIOS_FEEDBACK_PROGRAMAS AS FFP
# JOIN CAD_PESSOA AS CP
# ON FFP.ID_PESSOA = CP.ID_PESSOA
# JOIN INSCRICOES AS I
# ON FFP.ID_INSCRICAO = I.ID_INSCRICAO
# JOIN PROGRAMAS AS PR
# ON I.ID_PROGRAMA = PR.ID_PROGRAMA
# 
# GROUP BY TITULO_PROGRAMA

"""## Perguntas Adicionais Feedbacks"""

perguntas = [
    "Qual o seu nível de satisfação com os serviços oferecidos?",
    "Com que frequência você participa de eventos e workshops no Armazém?",
    "Serviços Mais Utilizados:",
    "Que melhorias você acredita que poderiam ser feitas no Armazém da Criatividade? E caso essas melhorias fossem implementadas, você teria maior probabilidade de utilizar mais os serviços oferecidos?"
]

def gerar_perguntas_adicionais():
    for i in range(len(perguntas)):
        # id_pergunta = str(uuid.uuid4())
        id_dominio = random.choice(ids_dominio)
        pergunta = perguntas[i]

        cursor.execute('''
            INSERT INTO PERGUNTAS_ADICIONAIS_FEEDBACK_PROGRAMAS (
                ID_DOMINIO, PERGUNTA
            )
            VALUES (?, ?)
        ''', (id_dominio, pergunta))

    # Comitar as inserções
    sqlite_conn.commit()

# Chamar a função para inserir dados
gerar_perguntas_adicionais()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM PERGUNTAS_ADICIONAIS_FEEDBACK_PROGRAMAS

"""## Respostas Formulários"""

cursor.execute('''
    SELECT PP.ID_INSCRICAO, P.ID_PESSOA
    FROM PARTICIPANTE_PROGRAMA AS PP
    JOIN INSCRICOES AS I ON PP.ID_INSCRICAO = I.ID_INSCRICAO
    JOIN CAD_PESSOA AS P ON I.ID_PESSOA = P.ID_PESSOA
''')
participantes = cursor.fetchall()

# Verificar se há participantes e selecionar metade deles aleatoriamente
total_participantes = len(participantes)
num_participantes_selecionados = max(1, total_participantes // 2)  # Seleciona metade dos participantes, mas garante pelo menos 1
participantes_selecionados = random.sample(participantes, k=num_participantes_selecionados)

# Consultar os IDs das perguntas da tabela PERGUNTAS_ADICIONAIS_FEEDBACK_PROGRAMAS
cursor.execute('SELECT ID_PERGUNTA FROM PERGUNTAS_ADICIONAIS_FEEDBACK_PROGRAMAS')
ids_perguntas = [row[0] for row in cursor.fetchall()]

# Gerar dados para RESPOSTAS_FEEDBACK_PROGRAMAS
def gerar_respostas_feedback():
    for participante in participantes_selecionados:
        id_inscricao = participante[0]
        id_pessoa = participante[1]

        # Obter o formulário correspondente ao participante (caso tenha relação)
        cursor.execute('SELECT ID_FORMULARIO FROM FORMULARIOS_FEEDBACK_PROGRAMAS WHERE ID_INSCRICAO = ?', (id_inscricao,))
        formulario_resultado = cursor.fetchone()

        if formulario_resultado:  # Verifica se há formulário relacionado à inscrição
            id_formulario = formulario_resultado[0]

            # Inserir uma resposta para cada pergunta
            for id_pergunta in ids_perguntas:
                # id_resposta = str(uuid.uuid4())

                # Obter a pergunta com base no ID da pergunta
                cursor.execute('SELECT PERGUNTA FROM PERGUNTAS_ADICIONAIS_FEEDBACK_PROGRAMAS WHERE ID_PERGUNTA = ?', (id_pergunta,))
                pergunta_resultado = cursor.fetchone()

                if pergunta_resultado:  # Verifica se foi encontrado um resultado
                    pergunta = pergunta_resultado[0]

                    # Gerar a resposta adequada para a pergunta
                    resposta = gerar_resposta_para_pergunta(pergunta)

                    # Inserir a resposta no banco de dados
                    cursor.execute('''
                        INSERT INTO RESPOSTAS_FEEDBACK_PROGRAMAS (
                            ID_PERGUNTA, ID_PESSOA, ID_FORMULARIO, RESPOSTA
                        )
                        VALUES (?, ?, ?, ?)
                    ''', (id_pergunta, id_pessoa, id_formulario, resposta))

    # Comitar as inserções
    sqlite_conn.commit()

# Função para gerar respostas para perguntas com base em suas descrições
def gerar_resposta_para_pergunta(pergunta):
    if "satisfação" in pergunta.lower():
        return random.choice(["Muito satisfeito", "Satisfeito", "Neutro", "Insatisfeito", "Muito insatisfeito"])
    elif "frequência" in pergunta.lower():
        return random.choice(["Diariamente", "Semanalmente", "Mensalmente", "Raramente"])
    elif "Serviços Mais Utilizados" in pergunta:
        return random.choice(["Edição de Imagem", "Podcast", "Fotografia", "Criação e Prototipagem", "Todos"])
    elif "melhorias" in pergunta.lower():
        return random.choice(["Mais equipamentos", "Mais workshops", "Melhor infraestrutura", "Mais divulgação"])
    else:
        return "N/A"

# Chamar a função para inserir dados
gerar_respostas_feedback()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT NOME_COMPLETO, TITULO_PROGRAMA, ID_FORMULARIO, ID_RESPOSTA
# FROM RESPOSTAS_FEEDBACK_PROGRAMAS AS RES
# JOIN CAD_PESSOA AS CAD
# ON RES.ID_PESSOA = CAD.ID_PESSOA
# JOIN INSCRICOES AS I
# ON RES.ID_PESSOA = I.ID_PESSOA
# JOIN PARTICIPANTE_PROGRAMA AS PP
# ON I.ID_INSCRICAO = PP.ID_INSCRICAO
# JOIN PROGRAMAS AS P
# ON PP.ID_PROGRAMA = P.ID_PROGRAMA
# WHERE TITULO_PROGRAMA = 'Minas na Produção'

"""## FEEDBACK PERGUNTAS INFRA"""

# Perguntas sobre a infraestrutura
perguntas_infra = [
    "Como você avalia a qualidade dos equipamentos disponíveis?",
    "O espaço físico do laboratório atende às suas necessidades?",
    "A infraestrutura de áudio e vídeo foi satisfatória?",
    "Os equipamentos estavam em boas condições de uso?",
    "A iluminação e a acústica dos espaços foram adequadas?",
    "Os recursos tecnológicos disponíveis foram suficientes para o trabalho?",
    "Houve facilidade no agendamento e uso dos laboratórios?",
    "A equipe de suporte foi eficiente e prestativa?",
    "Você encontrou problemas técnicos durante o uso dos equipamentos?",
    "Você recomendaria os laboratórios para outras pessoas?"
]

# Função para inserir perguntas na tabela FEEDBACK_PERGUNTAS_INFRAESTRUTURA
def inserir_perguntas_infra():
    for pergunta in perguntas_infra:
        # id_pergunta = str(uuid.uuid4())  # Gerar um ID único para cada pergunta
        cursor.execute('''
            INSERT INTO FEEDBACK_PERGUNTAS_INFRAESTRUTURA (PERGUNTA)
            VALUES (?)
        ''', (pergunta,))

    # Comitar as inserções
    sqlite_conn.commit()

# Chamar a função para inserir dados
inserir_perguntas_infra()

cursor.execute("SELECT * FROM FEEDBACK_PERGUNTAS_INFRAESTRUTURA")
teste = cursor.fetchall()
print(teste)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM FEEDBACK_PERGUNTAS_INFRAESTRUTURA

"""## Feedback Perguntas Infra"""

# Obter IDs de pessoas, agendamentos e perguntas de infraestrutura
cursor.execute('SELECT ID_PESSOA FROM CAD_PESSOA')
ids_pessoas = [row[0] for row in cursor.fetchall()]

cursor.execute('SELECT ID_AGENDAMENTO FROM AGENDAMENTO_SERVICO')
ids_agendamentos = [row[0] for row in cursor.fetchall()]

cursor.execute('SELECT ID_PERGUNTA FROM FEEDBACK_PERGUNTAS_INFRAESTRUTURA')
ids_perguntas_infra = [row[0] for row in cursor.fetchall()]

# Gerar respostas aleatórias para feedback de infraestrutura
def gerar_resposta_infra(pergunta):
    if "satisfação" in pergunta.lower():
        return random.choice(["Muito satisfeito", "Satisfeito", "Neutro", "Insatisfeito", "Muito insatisfeito"])
    elif "equipamentos" in pergunta.lower():
        return random.choice(["Muito adequados", "Adequados", "Neutro", "Inadequados", "Muito inadequados"])
    else:
        return random.choice(["Sim", "Não", "Talvez", "N/A"])

# Inserir dados de feedback de infraestrutura
def gerar_feedback_infraestrutura():
    for _ in range(50):  # Defina quantas respostas deseja gerar
        id_pessoa = random.choice(ids_pessoas)
        id_agendamento = random.choice(ids_agendamentos)

        for id_pergunta in ids_perguntas_infra:  # Iterar sobre as perguntas de infraestrutura
            cursor.execute('SELECT PERGUNTA FROM FEEDBACK_PERGUNTAS_INFRAESTRUTURA WHERE ID_PERGUNTA = ?', (id_pergunta,))
            pergunta_resultado = cursor.fetchone()

            if pergunta_resultado:
                pergunta = pergunta_resultado[0]
                resposta = gerar_resposta_infra(pergunta)  # Gerar resposta com base na pergunta

                # Inserir resposta no banco de dados
                cursor.execute('''
                    INSERT INTO FEEDBACK_INFRAESTRUTURA (
                        ID_PESSOA, ID_AGENDAMENTO, ID_PERGUNTA, RESPOSTA
                    ) VALUES (?, ?, ?, ?)
                ''', (id_pessoa, id_agendamento, id_pergunta, resposta))

    # Comitar as inserções
    sqlite_conn.commit()

# Executar a função para inserir os dados
gerar_feedback_infraestrutura()

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM FEEDBACK_INFRAESTRUTURA
# LIMIT 2

"""## Script para pegar o csv de todos os dados gerados"""

import time
cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
tables = cursor.fetchall()

# Criar um diretório para armazenar os CSVs
os.makedirs('csv_exports', exist_ok=True)

# Exportar cada tabela para um arquivo CSV
for table_name in tables:
    table_name = table_name[0]
    df = pd.read_sql_query(f"SELECT * FROM {table_name}",  sqlite_conn)
    df.to_csv(f'csv_exports/{table_name}.csv', sep=';', index=False)
from google.colab import files

import glob

# Caminho para o diretório onde os CSVs estão armazenados
csv_files = glob.glob('csv_exports/*.csv')

# Baixar cada arquivo CSV
for csv_file in csv_files:
    files.download(csv_file)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT *
# FROM ONU_ODS

